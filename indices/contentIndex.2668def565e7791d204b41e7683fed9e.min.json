{"/":{"title":"ü™¥ Quartz 3.2","content":"Host your second brain and [digital garden](https://jzhao.xyz/posts/networked-thought) for free. Quartz features\n\n1. Extremely fast full-text search by pressing `Ctrl` + `k`\n2. Customizable and hackable design based on Hugo\n3. Automatically generated backlinks, link previews, and local graph\n4. Built-in [[notes/CJK + Latex Support (ÊµãËØï) | CJK + Latex Support]]\n5. Support for both Markdown Links and Wikilinks\n\n## Get Started\n\u003e üìö [Setup your own digital garden using Quartz](notes/setup.md)\n\nNot convinced yet? Look at some [community digital gardens](notes/showcase.md) built with Quartz, or read about [why I made Quartz](notes/philosophy.md) to begin with.\n\n## Content Lists\nIf you prefer browsing the contents of this site through a list instead of a graph, you can find content lists here too:\n\n- [All Notes](/notes)\n- [Setup-related Notes](/tags/setup)\n\n## Troubleshooting\n- üöß [Troubleshooting and FAQ](notes/troubleshooting.md)\n- üêõ [Submit an Issue](https://github.com/jackyzha0/quartz/issues)\n- üëÄ [Discord Community](https://discord.gg/cRFFHYye7t)","lastmodified":"2022-04-24T19:07:33.106115151Z","tags":null},"/notes/Concatenation-and-Reversal-of-Strings":{"title":"Untitled Page","content":"##### Proof:\n$$\n\\begin{align}\n\u0026Proof \\ by \\  induction\\ on \\  |x| \\\\\n\u0026Base\\  Case:\\ |x| = 0.\\ Then\\ x = \\epsilon, and\\  (wx)^R  = (w\\epsilon)^R = w^R = (\\epsilon w)^R = (xw)^R.\\\\\n\u0026Prove: \\forall n \\ge, ((|x| = n) \\rightarrow ((wx)^R = x^Rw^R)) \\rightarrow ((|x| = n+1) \\rightarrow ((wx)^R = x^Rw^R)).\\\\ \\\\\n\u0026Consider\\  any\\  string\\  x,\\  where\\  |x| = n + 1.\\ Then\\  x = ua\\ for\\  some\\  character\\  a\\ and\\  |u| = n. So:\\\\\n\\end{align}\n$$\n$$\n\\begin{align}\n(w x)^R \u0026= (w (u a))^R  \\\\\n\t\t\u0026= ((w u) a)^R  \\\\\n\t\t\u0026= a (w u)^R  \\\\\n\t\t\u0026= a (u^R w^R )  \\\\\n\t\t\u0026= (a u^R) w^R \\\\\n\t\t\u0026= (ua)^R w^R  \\\\\n\t\t\u0026= x^R w^R \n\\end{align}\n$$\n\n","lastmodified":"2022-04-24T19:07:33.106115151Z","tags":null},"/notes/Concatenation-and-Reverse-of-Languages":{"title":"Untitled Page","content":"##### Proof:\n\n$$\n\\begin{align}\nIf\\ x\\ and\\ y\\ are\\ strings,\\ \u0026 then\\ \\forall x (\\forall y ((xy)^R = y^R x^R ))\\\\\n(L_1 L_2)^R \u0026= \\{(xy)^R : x \\in L_1\\ and\\ y \\in L_2\\}\\\\\n\t\t\t\u0026= {y^R x^R : x \\in L_1 and\\ y \\in L_2}\\\\\n\t\t\t\u0026= L_2^R L_1^R\n\\end{align}\n$$\n","lastmodified":"2022-04-24T19:07:33.106115151Z","tags":null},"/notes/DFSM-Halts":{"title":"Untitled Page","content":"$$\n\\begin{align}\nproof\u0026:\\\\\n\u0026On\\ input\\ w, M\\ executes\\ some\\ computation\\ C_0 |_{-M}\\ C_1 |_{-M}\\ C_2 |_{-M} ‚Ä¶ |_{-M} C_n,\\\\\n\u0026where\\ C_0\\ is\\ an\\ initial\\ configuration\\ and\\ Cn\\ is\\ of\\ the\\ form\\ (q, \\epsilon),\\\\\n\u0026for\\ some\\ state\\ q \\in K_M. C_n\\ is\\ either\\ an\\ accepting\\ or\\ a\\ rejecting\\ \\\\\n\u0026configuration,\\ so\\ M\\ will\\ halt\\ when\\ it\\ reaches\\ C_n.\\ Each\\ step\\ in\\ the\\ \\\\\n\u0026computation\\ consumes\\ one\\ character\\ of\\ w.\\ So\\ n = |w|.\\ Thus\\ M\\ will\\ halt\\\\\n\u0026after\\ |w|\\ steps\n\\end{align}\n$$\n","lastmodified":"2022-04-24T19:07:33.106115151Z","tags":null},"/notes/Deterministic-Finite-Automata":{"title":"Untitled Page","content":"---\n\n\n#### Deterministic Finite Automata","lastmodified":"2022-04-24T19:07:33.106115151Z","tags":null},"/notes/Finite-Automata":{"title":"Untitled Page","content":"---\n\n#### Finite Automata","lastmodified":"2022-04-24T19:07:33.106115151Z","tags":null},"/notes/Language-Hierarchy":{"title":"Untitled Page","content":"#### Language Hierarchy\n---\n##### A Machine-Based Hierarchy of Language Classes\n\n- ###### The Regular Languages\n\n\t- We will call the class of languages that can be accepted by some [[Finite Automata|FSM]] **regular**.\n\n$$\n\\begin{align}\nfor\\ examp\u0026le,\\\\\n\u0026Let\\ L = \\{w \\in \\sum*: where\\ all\\ a‚Äôs\\ come\\ before\\ all\\ b‚Äôs\\}\\\\\n\u0026\\{a, b\\} \\in \\sum\n\\end{align}\n$$\n\n![Image](abeforeb.svg)\n\n- ###### The Context-Free Languages\n\t- The language which is not accepted by FSM and accepted by **Pushdown Automata** a **Context-Free** Languages\n\n$$\n\\begin{align}\nFor\\ examp\u0026le,\\\\\n\u0026Let\\ A^nB^n = \\{a^nb^n:n \\ge 0\\}\\\\\n\u0026\\{a, b\\} \\in \\sum\n\\end{align}\n$$\n![[anbn.svg]]\n#### The Decidable and Semdecidable Languages\n##### Turing Machine\nWe will get rid of the stack of **Pushdown automata** and replace it with an infinite tape. The tape will have a single read/write head. Only the tape square under the read/write head can be accessed (for reading or for writing). The read/write head can be moved one square in either direction on each move. The resulting machine is called a **Turing machine**\n\n - A language L is decidable iff there exists a Turing machine M that halts on all inputs, accepts all strings that are in L, and rejects all strings that are not in L. In other words, M can always say yes or no, as appropriate.\n - A language L is semidecidable iff there exists a Turing machine M that halts on all inputs, accepts all strings that are in L, and fails to accept every string that is not in L. Given a string that is not in L, M may reject or it may loop forever. In other words, M can recognize a solution and then say yes, but it may not know when it should give up looking for a solution and say no.","lastmodified":"2022-04-24T19:07:33.106115151Z","tags":null},"/notes/Languages":{"title":"Untitled Page","content":"#### Languages\n---\nA language is a(finite or infinite) set of strings over a finite alphabet $\\sum$.\n\n\u003e[!Note]\n\u003e##### The Empty Language\n$Let\\ L = \\{\\} = \\phi$.\n\u003e L is the language that contains no strings\n\u003e ##### The Empty Language is Different From the Empty String\n\u003e$Let = \\{\\epsilon\\}$, the language that contains a single string, $\\epsilon$.\n\u003eL is different from $\\epsilon$ \n\n##### Cardinality of a Language\nThe largest language over any alphabet $\\sum$ is $\\sum$*. \n\n$$\n\\begin{align}\n\u0026if\\ \\sum \\neq \\phi.\n\u0026Then\\ \\sum* = \\{\\epsilon\\}\\ and\\ |\\sum*| = 1 \n\\end{align}\n$$\n\n##### Theorem The Cardinality of $\\sum$*\n\u003e[!INFO]\nTheorem: If $\\sum \\neq \\phi$, then $\\sum*$ is countably infinite.\n\n##### Theorem An Uncountably Infinite Number of Languages\nc\n\n##### Kleene  Star\nLet L be a language defined over some alphabet $\\sum$. Then the Kleene star of L, written L* is:\n$$\n\\begin{align}\n\u0026L* = \\{\\epsilon\\} \\cup \\{w \\in \\sum* : \\exists k \\geq 1 (\\exists w_1, w_2, ‚Ä¶ w_k \\in L (w = w_1 w_2 ‚Ä¶ w_k))\\}.\n\\end{align}\n$$\n$L^+ = LL^*$\n$L^+ = L^* - \\{\\epsilon\\}$\n\n##### Theorem ![[Concatenation and Reverse of Languages]]\n\u003e[!INFO]\nTheorem: If $L_1$ and $L_2$ are languages, then $(L1 L2)^R = L_2^R L_1^R$\n\n[next](obsidian://open?vault=Theory%20Of%20Computation\u0026file=Language%20Hierarchy)\n","lastmodified":"2022-04-24T19:07:33.106115151Z","tags":null},"/notes/Non-deterministic-Automata":{"title":"Untitled Page","content":"---\n\n#### Non-Deterministic Automata","lastmodified":"2022-04-24T19:07:33.106115151Z","tags":null},"/notes/Theory-Of-Computation":{"title":"Untitled Page","content":"# Theory Of Computation\n---\n## Languages And Strings\n### Alphabet\n\nAn alphabet is denoted by $\\sum$ , a finite set. The members of $\\sum$ are called symbols and characters.\n\n### Strings\nA string is a finite sequence, possibly empty, of symbols drawn from some alphabet $\\sum$. The shortest string that can be formed is the empty string, written as $\\epsilon$. The set of all possible strings over an alphabet $\\sum$ is written $\\sum$*. \n\n### Functions On Strings\n#### Length of string\nThe **length** of a string s, which we will write as $|s|$, is the number of symbols in $s$. \n$For \\  Example$\n$$\n\\begin{aligned}\n|\\epsilon| = 0 \\\\\n|1001101| = 7\n\\end{aligned}\n$$ \n#### Concatenation of string\nThe **concatenation** of two strings $s$ and $t$, written $s || t$ or simply $st$, is the string formed by appending $t$ to $s$. \n$For \\  example$\n\n$$\n\\begin{aligned}\nif \\  x = good \\  and \\  y = bye, \\\\ then \\  xy = goodbye. \\\\ So \\  |xy| = |x| + |y|. \n\\end{aligned}\n$$ \nThe empty string, $\\epsilon$ , is the identity for concatenation of strings. So $\\forall x (x\\epsilon= \\epsilon x = x)$.\n\nConcatenation, as a function defined on strings, is associative. So $\\forall s, t, w ((st)w = s(tw))$.\n\nFor each string $w$ and each natural number $i$, the string $w^i$ is defined as: $w^0 = \\epsilon, \\  w^{i+1} = w^i w$ \n\n#### String Reversal\nFor each string $w$, the reverse of $w$, which we will write $w^R$ , is defined as: \n$$\n\\begin{aligned}\nif \\ |w| = 0 \\ then \\  w^R = w = \\epsilon \\\\\nif |w| \\ge  1 then\\  \\exists a \\in \\epsilon (\\exists u \\in \\sum* (w = ua)).\\\\ Then \\ define \\  w^R = a u^R .\n\\end{aligned}\n$$\n\n##### Theorem ![[Concatenation and Reversal of Strings]]\n\u003e[!INFO]\nTheorem: If $w$ and $x$ are strings, then $(wx)^R = x^R w^R$ .\n\n#### Relations on Strings\nA string $s$ is a **substring** of a string $t$ iff $s$ occurs contiguously as part of $t$. \n$$\n\\begin{align}\nFor\\ example:\\\\\n\u0026aaa\\ is\\ a\\ substring\\ of\\ aaabbbaaa\\\\\n\u0026aaaaaa\\ is\\ not\\ a\\ substring\\ of\\ aaabbbaaa\n\\end{align}\n$$\nA string $s$ is a **proper substring** of a string $t$ iff $s$ is a substring of $t$ and $s \\neq t$.\n\nEvery string is a substring of itself. The empty string, $\\epsilon$, is a substring of every string.\n\nA string $s$ is a **prefix** of $t$ iff $\\exists x \\in \\sum* (t = sx)$. A string s is a **proper prefix** of a string $t$ iff $s$ is a prefix of $t$ and $s \\neq t$. Every string is a prefix of itself. The empty string, $\\epsilon$, is a prefix of every string. \n$$\n\\begin{align}\nFor\\ example,\\\\\n\u0026the\\ prefixes\\ of\\ abba\\ are: \\epsilon, a, ab, abb, abba.\n\\end{align}\n$$\nA string $s$ is a **suffix** of $t$ iff $\\exists x \\in \\sum* (t = xs)$. A string s is a **proper suffix** of a string $t$ iff $s$ is a suffix of $t$ and $s \\neq t$. Every string is a suffix of itself. The empty string, $\\epsilon$, is a suffix of every string. \n\n$$\n\\begin{align}\nFor\\ example,\\\\\n\u0026the\\ suffixes\\ of\\ abba\\ are: \\epsilon, a, ba, bba, abba.\n\\end{align}\n$$\n\n[[Languages]]\n[[Language Hierarchy]]\n[[Finite Automata]]\n\n\n\n","lastmodified":"2022-04-24T19:07:33.106115151Z","tags":null}}